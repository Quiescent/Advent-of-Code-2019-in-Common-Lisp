(ql:quickload "iterate")

(defpackage :hash-table-computer
  (:use :common-lisp)
  (:use :iter)
  (:export interpret)
  (:export parse-computer-registers)
  (:export *relative-base*)
  (:export copy-computer))

(in-package :hash-table-computer)

(defun copy-computer (computer)
  (iter
    (with new-computer = (make-hash-table :test #'eq))
    (for (key value) in-hashtable computer)
    (setf (gethash key new-computer) value)
    (finally (return new-computer))))

(defun parse-computer-registers (input-elements)
  (iter
    (with result = (make-hash-table :test #'eq))
    (for i from 0)
    (for number in (str:words (ppcre:regex-replace-all ","
                                                       (car input-elements)
                                                       " ")))
    (setf (gethash i result) (read-from-string number))
    (finally (return result))))

(defun arg-1-mode (x)
  (declare (type fixnum x))
  (case (floor (mod x 1000) 100)
    (2 'relative)
    (1 'immediate)
    (0 'position)))

(defun arg-2-mode (x)
  (declare (type fixnum x))
  (case (floor (mod x 10000) 1000)
    (2 'relative)
    (1 'immediate)
    (0 'position)))

(defun arg-3-mode (x)
  (declare (type fixnum x))
  (case (floor x 10000)
    (2 'relative)
    (1 'immediate)
    (0 'position)))

(defun get-arg-1 (ptr program)
  (declare (type fixnum ptr))
  (let ((op (gethash ptr program 0))
        (p1 (gethash (+ ptr 1) program 0)))
    (declare (type fixnum op))
    (declare (type fixnum p1))
    (case (arg-1-mode op)
      (immediate p1)
      (position  (gethash p1 program 0))
      (relative  (gethash (+ p1 *relative-base*) program 0)))))

(defun get-arg-2 (ptr program)
  (declare (type fixnum ptr))
  (let ((op (gethash ptr program 0))
        (p2 (gethash (+ ptr 2) program 0)))
    (declare (type fixnum op))
    (declare (type fixnum p2))
    (case (arg-2-mode op)
      (immediate p2)
      (position  (gethash p2 program 0))
      (relative  (gethash (+ p2 *relative-base*) program 0)))))

(defun get-arg-3 (ptr program)
  (declare (type fixnum ptr))
  (let ((op (gethash ptr program 0))
        (p3 (gethash (+ ptr 3) program 0)))
    (declare (type fixnum op))
    (declare (type fixnum p3))
    (case (arg-3-mode op)
      (immediate p3)
      (position  (gethash p3 program 0))
      (relative  (gethash (+ p3 *relative-base*) program 0)))))

(defun get-dest-1 (ptr program)
  (declare (type fixnum ptr))
  (let ((op (gethash ptr program 0))
        (p1 (gethash (+ ptr 1) program 0)))
    (declare (type fixnum op))
    (declare (type fixnum p1))
    (or (case (arg-1-mode op)
          (position  p1)
          (relative  (+ p1 *relative-base*)))
        p1)))

(defun get-dest-2 (ptr program)
  (declare (type fixnum ptr))
  (let ((op (gethash ptr program 0))
        (p2 (gethash (+ ptr 2) program 0)))
    (declare (type fixnum op))
    (declare (type fixnum p2))
    (or (case (arg-2-mode op)
          (position  p2)
          (relative  (+ p2 *relative-base*)))
        p2)))

(defun get-dest-3 (ptr program)
  (declare (type fixnum ptr))
  (let ((op (gethash ptr program 0))
        (p3 (gethash (+ ptr 3) program 0)))
    (declare (type fixnum op))
    (declare (type fixnum p3))
    (or (case (arg-3-mode op)
          (position  p3)
          (relative  (+ p3 *relative-base*)))
        p3)))

;; Uses anaphors for p1..p3, d1..d3 program and ptr.
;; Only valid in this package!!
(defmacro defcpu (ops)
  `(let ((p1 (let ((res)) (lambda () (or res (setf res (get-arg-1 ptr program))))))
         (p2 (let ((res)) (lambda () (or res (setf res (get-arg-2 ptr program))))))
         (p3 (let ((res)) (lambda () (or res (setf res (get-arg-3 ptr program))))))
         (d1 (let ((res)) (lambda () (or res (setf res (get-dest-1 ptr program))))))
         (d2 (let ((res)) (lambda () (or res (setf res (get-dest-2 ptr program))))))
         (d3 (let ((res)) (lambda () (or res (setf res (get-dest-3 ptr program)))))))
     (case (mod (gethash ptr program 0) 10)
       ,@(mapcar (lambda (op) (list (car op) (replace-anaphors (cadr op)))) ops))))

(defun replace-anaphors (xs)
  (cond
    ((null  xs)       nil)
    ((listp (car xs)) (cons (replace-anaphors (car xs))
                            (replace-anaphors (cdr xs))))
    ((eq (car xs) 'p1) (cons '(funcall p1) (replace-anaphors (cdr xs))))
    ((eq (car xs) 'p2) (cons '(funcall p2) (replace-anaphors (cdr xs))))
    ((eq (car xs) 'p3) (cons '(funcall p3) (replace-anaphors (cdr xs))))
    ((eq (car xs) 'd1) (cons '(funcall d1) (replace-anaphors (cdr xs))))
    ((eq (car xs) 'd2) (cons '(funcall d2) (replace-anaphors (cdr xs))))
    ((eq (car xs) 'd3) (cons '(funcall d3) (replace-anaphors (cdr xs))))
    (t                 (cons (car xs) (replace-anaphors (cdr xs))))))

(defvar *relative-base*)

(defun interpret (program input ptr)
  (iter
    (for op = (gethash ptr program 0))
    (declare (type fixnum op))
    (when (eq op 99)
      (format t "BAILING!~%")
      (return (values ptr nil t nil)))
    (with current-input = input)
    (defcpu ((1 (setf (gethash d3 program 0) (+ p1 p2)
                      ptr               (+ ptr 4)))
             (2 (setf (gethash d3 program 0) (* p1 p2)
                      ptr               (+ ptr 4)))
             (3 (setf (gethash d1 program 0) (if (null current-input)
                                            (progn
                                              (format t "Reading...~%")
                                              (return (values ptr nil nil t)))
                                            (prog1
                                              input
                                              (setq current-input nil)))
                      ptr               (+ ptr 2)))
             (4 (return (values (+ ptr 2) p1 nil nil)))
             (5 (if (not (eq 0 p1))
                    (setf ptr p2)
                    (setf ptr (+ ptr 3))))
             (6 (if (eq 0 p1)
                    (setf ptr p2)
                    (setf ptr (+ ptr 3))))
             (7 (setf (gethash d3 program 0) (if (< p1 p2) 1 0)
                      ptr               (+ ptr 4)))
             (8 (setf (gethash d3 program 0) (if (eql p1 p2) 1 0)
                      ptr               (+ ptr 4)))
             (9 (setf *relative-base* (+ *relative-base* p1)
                      ptr             (+ ptr 2)))))
    (finally (return nil))))
