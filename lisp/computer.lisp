(ql:quickload "iterate")

(defpackage :computer
  (:use :common-lisp)
  (:use :iter)
  (:export interpret)
  (:export parse-computer-registers))

(in-package :computer)

(defun parse-computer-registers (lines-numbers)
  (map 'vector #'identity (car lines-numbers)))

(defun arg-1-mode (x)
  (if (eq (floor (mod x 1000) 100) 1)
      'immediate
      'position))

(defun arg-2-mode (x)
  (if (eq (floor (mod x 10000) 1000) 1)
      'immediate
      'position))

(defun arg-3-mode (x)
  (if (eq (floor x 10000) 1)
      'immediate
      'position))

(defun interpret (array)
  (iter
    (with ptr = 0)
    (when (or (> ptr (length array))
              (< ptr 0))
      (error (format nil "Pointer: ~a is out of bounds!" ptr)))
    (for op = (aref array ptr))
    (for op-type = (mod op 10))
    ;; (format t "program: ~a~%" array)
    ;; (format t "op: ~a~%" op)
    ;; (format t "ptr: ~a~%" ptr)
    (cond
      ((eq op 99) (return))
      ((eq op-type 1)  (let ((p1   (aref array (+ ptr 1)))
                             (p2   (aref array (+ ptr 2)))
                             (dest (aref array (+ ptr 3))))
                         (setf (aref array dest)
                               (+ (if (eq (arg-1-mode op) 'immediate) p1 (aref array p1))
                                  (if (eq (arg-2-mode op) 'immediate) p2 (aref array p2)))
                               ptr               (+ ptr 4))))
      ((eq op-type 2) (let ((p1   (aref array (+ ptr 1)))
                            (p2   (aref array (+ ptr 2)))
                            (dest (aref array (+ ptr 3))))
                        (setf (aref array dest)
                              (* (if (eq (arg-1-mode op) 'immediate) p1 (aref array p1))
                                 (if (eq (arg-2-mode op) 'immediate) p2 (aref array p2)))
                              ptr               (+ ptr 4))))
      ((eq op-type 3) (let ((dest (aref array (+ ptr 1))))
                        (setf (aref array dest) (progn (format t "Please input a number: ") (read))
                              ptr               (+ ptr 2))))
      ((eq op-type 4) (let ((p1 (aref array (1+ ptr))))
                        (print (if (eq (arg-1-mode op) 'immediate) p1 (aref array p1)))
                        (setf ptr (+ ptr 2))))
      ((eq op-type 5) (let ((p1 (aref array (1+ ptr)))
                            (p2 (aref array (+ ptr 2))))
                        (if (not (eq 0 (if (eq (arg-1-mode op) 'immediate) p1 (aref array p1))))
                            (setf ptr (if (eq (arg-2-mode op) 'immediate) p2 (aref array p2)))
                            (setf ptr (+ ptr 3)))))
      ((eq op-type 6) (let ((p1 (aref array (1+ ptr)))
                            (p2 (aref array (+ ptr 2))))
                        (if (eq 0 (if (eq (arg-1-mode op) 'immediate) p1 (aref array p1)))
                            (setf ptr (if (eq (arg-2-mode op) 'immediate) p2 (aref array p2)))
                            (setf ptr (+ ptr 3)))))
      ((eq op-type 7) (let ((p1 (aref array (1+ ptr)))
                            (p2 (aref array (+ ptr 2)))
                            (p3 (aref array (+ ptr 3))))
                        (setf (aref array p3)
                              (if (< (if (eq (arg-1-mode op) 'immediate) p1 (aref array p1))
                                     (if (eq (arg-2-mode op) 'immediate) p2 (aref array p2)))
                                  1
                                  0))
                        (setf ptr (+ ptr 4))))
      ((eq op-type 8) (let ((p1 (aref array (1+ ptr)))
                            (p2 (aref array (+ ptr 2)))
                            (p3 (aref array (+ ptr 3))))
                        (setf (aref array p3)
                              (if (eql (if (eq (arg-1-mode op) 'immediate) p1 (aref array p1))
                                       (if (eq (arg-2-mode op) 'immediate) p2 (aref array p2)))
                                  1
                                  0))
                        (setf ptr (+ ptr 4)))))))
